<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title></title>
</head>
<body>

	<a href="?x0-ff">to display all unicode symbols by it's code from 0 to ff (or 255) press this or add "?x0-ff" after curent url</a><br><br>
	<!-- <a href="?a0-nvnj">to display all unicode symbols press this or add "?a0-nvnj" (nvnj is 0x10FFFF in base36) after curent url</a><br><br> -->


<div id="text">
</div>
<style type="text/css">
	table {
		border-collapse: collapse;
		font-family: monospace;
	}

	table td, table th {
		border: 0.1em solid #a2a9b1;
		padding: 0.2em;
		text-align: center;
	}

	thead th, tbody th {
		position: sticky;
		position: -webkit-sticky;
	}

	thead th {
		top: 0;
	}

	tbody th {
		left: 0;		
	}

	table th {
		background-color: #f8f9fa;
	}

	caption {
		padding: 0.5em;
	}

	caption > span {
		text-decoration: underline;
		cursor: pointer;
	}

	caption > span.copied:before {
		content: "copied";
		padding: 0.25em;
		background-color: #eee;
		border-radius: 0.5em;
		outline: 0.1em solid #000;
		position: absolute;
		opacity: 0;
/*		transform: translate(0, -125%);*/
		animation: move-up 1s ease-in;
	}

	@keyframes move-up {
		0%   {transform: translateY( -50%); opacity: 1;}
		100% {transform: translateY(-125%); opacity: 0;}
	}	

	.outOfBounds {
		background-color: #dadde3;
	}
</style>

<script type="text/javascript">

// let start = 0
// let end = 2_000
// let symbol = ''

function display(obj,norec,tab='') {
  let result = '';
    if (typeof obj === 'object') {
        norec.push(obj)
    }
    
  let keys = Object.keys(obj).slice(0,100)
    if (keys.length === 0) {
        keys = Object.keys(Object.getOwnPropertyDescriptors(obj.constructor.prototype)).slice(0,100)
    }
    
  for (let i = 0; i<keys.length; i++) {
    const thisTab = (i==keys.length-1?' \u2514\u2500 ':' \u251c\u2500 ')
    if (typeof obj[keys[i]] === 'object' && obj[keys[i]] != null) {
            if ( norec.includes(obj[keys[i]]) ) {
                result += `${tab + thisTab}${keys[i]}: ... (was loged higher)\n`
            } else {
                const line = `${tab + thisTab}${keys[i]}: (${obj[keys[i]]?.constructor.name})\n`
                result += line + display(obj[keys[i]], norec, tab+(i==keys.length-1?'    ':' \u2502  '))
            }
      
    } else {
      switch (obj[keys[i]]?.constructor.name) {
        case 'String'  : var textCol = '\x1b[38;2;92;213;251m';  break;
        case 'Number'  : var textCol = '\x1b[38;2;153;128;255m'; break;
        case 'Boolean' : var textCol = '\x1b[38;2;236;96;102m';  break;
        case 'Function': var textCol = '\x1b[38;2;250;201;24m';  break;
        default:         var textCol = ''; break;
      }
      result += `${tab + thisTab}${keys[i]}: ${textCol}${obj[keys[i]]}\x1b[0m (${obj[keys[i]]?.constructor.name})\n` //
    }
  }
  return result
}



function baseStr(int,base=10) {
	return `${int.toString(base)}${String.fromCodePoint(...base.toString().split('').map(a=>0x2080+parseInt(a)))}`
}


function addSymbols(from, to, w, link) {
	const dce = s=>document.createElement(s);
	// const h = Math.ceil((to-from)/w)

	const table = dce('table')
	const caption = table.appendChild(dce('caption'))
	caption.textContent = `unicode symbols by codePoint in range ${baseStr(from,16)}-${baseStr(to,16)} or ${baseStr(from)}-${baseStr(to)} `

	const span = caption.appendChild(dce('span'))
	span.textContent = 'copy link on table below'
	span.addEventListener('click',c=>{
		navigator.clipboard.writeText(link)
		
		if (span.getAttribute('timeoutID') != undefined) {
			span.classList.remove('copied')
			clearTimeout(parseInt(span.getAttribute('timeoutID')))
			// span.removeAttribute('timeoutID')
		}

		span.classList.add('copied')
		span.setAttribute('timeoutID', setTimeout(()=>{
			span.classList.remove('copied')
			span.removeAttribute('timeoutID')
		}, 1000))
	})

	const a = caption.appendChild(dce('a'))
	a.setAttribute('href', link)
	a.textContent = 'open only table below'


// navigator.clipboard.writeText('hello here')

	const thead = table.appendChild(dce('thead'))
	thead.appendChild(dce('th'))
	for (let i = 0; i < w; i++) {
		thead.appendChild(dce('th')).textContent = `${i.toString(16).padStart(Math.ceil(Math.log2(w)/4),'0')}`
	}

	const tbody = table.appendChild(dce('tbody'))
	for (let i = Math.floor(from/w)*w; i < Math.ceil(to/w)*w; i+=w) {
		const tr = tbody.appendChild(dce('tr'))
		const th = tr.appendChild(dce('th'))
		th.textContent = `0x${i.toString(16).padStart(Math.ceil(Math.log2(to)/4),'0')}+${'.'.repeat(Math.ceil(Math.log2(w)/4))}`

		for (let j = i; j < i+w; j++) {
			const td = tr.appendChild(dce('td'))
			td.textContent = String.fromCodePoint(j)
			if (j < from || j > to) {
				td.classList.add('outOfBounds')
			}
		}
	}

	return table
}

const searchCheckParse = {
	codePointBounds: {
		// ...x0-5f6...
		default: undefined,

		// limits for symbols per number set by max supported utf symbol code (0x10FFFF)
		regBin   :'(?<base>b)(?<n0>[01]{1,21})(?<type>\\+-|-)(?<n1>[01]{1,21})',
		regDec   :'(?<base>d)(?<n0>[0-9]{1,7})(?<type>\\+-|-)(?<n1>[0-9]{1,7})',
		regHex   :'(?<base>x)(?<n0>[0-9a-f]{1,6})(?<type>\\+-|-)(?<n1>[0-9a-f]{1,6})',
		regBase36:'(?<base>a)(?<n0>[0-9a-z]{1,4})(?<type>\\+-|-)(?<n1>[0-9a-z]{1,4})',
		get reg(){return `${this.regBin}|${this.regDec}|${this.regHex}|${this.regBase36}`},

		parseNames: ['base','type','n0','n1'],
		parseSteps: [{
			base: o=>({'b':2,'d':10,'x':16,'a':36})[o.base],
		},{
			n0: o=>parseInt(o.n0,o.base),
			n1: o=>parseInt(o.n1,o.base),
		},{
			n0: o=>o.type==='+-' ? Math.max(o.n0-o.n1,0) : o.n0,
			n1: o=>o.type==='+-' ?          o.n0+o.n1    : o.n1,
		},{
			n1: o=>Math.min(o.n1, 0x10FFFF)
		},{
			n0: o=>Math.min(o.n0, o.n1)
		}],
		toUrlPart: o=>`x${o.n0.toString(16)}-${o.n1.toString(16)}`
		// toUrlPart: o=>{
		// 	//({2:'b',10:'d',16:'x',36:'a'})[o.base]
		// }
	},
	linesPerTable: {
		// ...L4...
		default: {count: 4},

		reg: 'L(?<count>[0-9]{1,3})', //max: 999
		parseNames: ['count'],
		parseSteps: [{
			count: o=>parseInt(o.count),
		}],
		toUrlPart(o) {return o.count === this.default.count ? '' : `L${o.count}`}
	},
	symbolsPerLine: {
		// ...S64...
		default: {count: 64},

		reg: 'S(?<count>[0-9]{1,3})', //max: 999
		parseNames: ['count'],
		parseSteps: [{
			count: o=>parseInt(o.count),
		}],
		toUrlPart(o) {return o.count === this.default.count ? '' : `S${o.count}`}
	}
}

function getSearchParams(search,regDict = searchCheckParse) {
	const requiredCount = Object.keys(regDict).reduce((ac,key)=>ac+(regDict[key].default===undefined),0)
	const allCount = Object.keys(regDict).length
	const fullReg = `(?:${Object.values(regDict).map(v=>v.reg).join('|')})`

	if ( new RegExp(`(?<=^\\?)${fullReg}{${requiredCount},${allCount}}$`).test(search) ) {
		const matched = {}
		for (key in regDict) {
			if ( new RegExp(regDict[key].reg).test(search) ) {
				const match = search.match(new RegExp(regDict[key].reg, 'g'))
				if (match.length > 1) {
					console.error(`structure ${key} appeats twice or more`,match)
				}
				const preRarsedResult = Object.fromEntries(match[0].replaceAll(
					 new RegExp(regDict[key].reg, 'g')
					,regDict[key].parseNames.map(a=>`$<${a}>`
				).join(' ')).split(' ').map((a,i)=>[regDict[key].parseNames[i],a]))

				for (step of regDict[key].parseSteps) {
					let temp = {}
					for (variable in step) {
						temp[variable] = step[variable](preRarsedResult)
					}
					Object.assign(preRarsedResult, temp)
				}
				matched[key] = preRarsedResult
			} else {
				if (regDict[key].default === undefined) {
					console.error(`${key} must be in search string, but regExp can't find ${key} in it, looks like other structure appeats twice or more`)
				} else {
					matched[key] = regDict[key].default;
				}
			}
		}
		return matched
	} else {
		console.error('search don`t match regDict')
	}
}

function urlByParams(params,regDict = searchCheckParse) {
	let result = '?'
	for (key in params) {
		result+=regDict[key].toUrlPart(params[key])
	}
	return result
}

// structuredClone(getSearchParams(window.location.search))

/* // old version of code below
if (window.location.search.length > 1) {
	// limits for symbols per number set by max supported utf symbol code (0x10FFFF)
	const regBin    = '(?<base>b)(?<n0>[01]{1,21})-(?<n1>[01]{1,21})'
	const regDec    = '(?<base>d)(?<n0>[0-9]{1,7})-(?<n1>[0-9]{1,7})'
	const regHex    = '(?<base>x)(?<n0>[0-9a-f]{1,6})-(?<n1>[0-9a-f]{1,6})'
	const regBase36 = '(?<base>a)(?<n0>[0-9a-z]{1,4})-(?<n1>[0-9a-z]{1,4})'
	var fullReg   = `^\\?(?:${regBin}|${regDec}|${regHex}|${regBase36})$`

	if ( new RegExp(fullReg).test(window.location.search) ) {
		const props = window.location.search.replaceAll(new RegExp(fullReg,'g'),'$<base> $<n0> $<n1>').split(' ')
		const base = ({'b':2,'d':10,'x':16,'a':36})[props[0]]
		var n0 = parseInt(props[1],base)
		var n1 = parseInt(props[2],base)
		n1 = Math.min(n1, 0x10FFFF)
		n0 = Math.min(n0, n1)
		console.log(props,[base,n0,n1])

		const symbolsPerTable = 256
		for (let i = Math.floor(n0/symbolsPerTable)*symbolsPerTable; i < Math.ceil(n1/symbolsPerTable)*symbolsPerTable; i+=symbolsPerTable) {
			document.querySelector('#text').appendChild(addSymbols( Math.max(i,n0), Math.min(i+symbolsPerTable,n1) ))
		}
		
	} else {
		alert(`${window.location.search} must be in format:\n ?{b or d or x or a}{start}-{end}\n\nfull regExp which is testing string: ${fullReg}`)
		console.error()
	}
}
*/

if (window.location.search.length > 1) {
	const params = getSearchParams(window.location.search)
	console.log(window.location.search, urlByParams(params))

	const symbolsPerTable = params.linesPerTable.count*params.symbolsPerLine.count
	const tableStart = Math.floor(params.codePointBounds.n0/symbolsPerTable)*symbolsPerTable
	const tableEnd   = Math.ceil (params.codePointBounds.n1/symbolsPerTable)*symbolsPerTable

	for (let i = tableStart; i < tableEnd; i+=symbolsPerTable) {
		document.querySelector('#text').appendChild(addSymbols(
			 Math.max(i                ,params.codePointBounds.n0)
			,Math.min(i+symbolsPerTable,params.codePointBounds.n1)
			,params.symbolsPerLine.count
			,'test link'
		))
	}
}

</script>	
</body>
</html>